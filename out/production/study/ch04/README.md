# CH4 조건문과 반복문
* 조건에 따라 문장을 건너뛰고, 때로는 같은 문장을 반복해서 수행할때등의 상황처럼 프로그램의 흐름을 바꾸는 역할을 하는 문장들을 **제어문(control statement)** 라고 한다.
* **제어문** : **조건문**, **반복문**
* **조건문** : 조건에따라 다른 문장이 수행
* **반복문** : 특정 문장들을 반복해서 수행

#  <조건문> - if, switch
###=> 조건문 : 조건식과 문장을 포함하는 블럭{}으로 구성되어 있음, 프로그램의 실행흐름 변경가능, 주로 if문이 많이 사용 처리할 수가 많을 때는 if보단 switch가 효율적이지만 switch는 제약이 많음

## 1. if문 : 가장 기본적인 조건문, 조건식과 괄호{}로 이루어짐 => 만일(if) 조건식이 참 (true)이면 괄호{} 안의 문장들을 수행하라는 의미

```java
if(조건식) {        } // 조건식이 참(true)일 떄 수행될 문장들을 적는다
```
### - 조건식 : if문에 사용되는 조건식은 일반적으로 비교연산자와 논리연산자로 구성된다.
### <자주 사용되는 조건식>
1) 90 <= x && x <= 100 (정수 x가 90이상 100이하 일 때)
2) x < 0 || x > 100 (정수 x가 0보다 작거나 100보다 클 때)
3) x%3==0 && x%2!=0 (정수 x가 3의 배수지만 2의 배수는 아닐 때)
4) ch=='y' || ch=='Y' (문자 ch가 'y'또는 'Y'일 때)
5) ch==' ' || ch=='\t' \\ ch=='\n' (문자 ch가 공백이거나 탭또는 개행 문자일 때)
6) 'A' <= ch && ch <= 'Z' (문자 ch가 대문자일 때)
7) 'a' <= ch && ch <= 'z' (문자 ch가 소문자일 때)
8) '0' <= ch && ch <= '9' (문자 ch가 숫자일 때)
9) str.equals("yes") {문자열 str의 내용이 "yes"일 때(대소문자 구분)}
10) str.equalsTgnoreCase("yes") {문자열 str의 내용이 "yes"일 때(대소문자 구분안함)}

### - 블럭 {}
=> 괄호{}를 이용해서 여러 문장을 하나의 단위로 묶는 rjt
1) 블록 내 문장이 하나일 때는 블록({}) 생략가능

### - if-else문
=> if문의 변형, if문에 'else블럭'이 더 추가되었다.(else : 그 밖의 다른), 즉 조건식의 결과가 참이 아닐 때 즉 거짓일 때 else블럭의 문장을 수행한다.

```if(조건식) { 
// 조건식이 참(true)일 때 수행될 문장들을 적는다.
} else {
// 조건식이 거짓(false)일 때 수행될 문장들을 적는다.
```

###- if-else if문
=> 두 가지 경우 중 하나가 수행되는 구조인데, 처리해야 할 경우가 셋 이상인 경우에 사용

```if (조건식1) {
// 조건식1의 연산결과가 참일 때 수행될 문장들을 적는다.
} else if (조건식2) {
// 조건식2의 연산결과가 참일 때 수행될 문장들을 적는다.
} else if (조건식3) { // 여러 개의 else if를 사용할 수 있다.
// 조건식3의 연산결과가 참일 때 수행될 문장들을 적는다.
} else { // 마지막에는 보통 else블럭으로 끝나며, else블럭은 생략가능하다.
// 위의 어떤 조건식도 만족하지 않을 때 수행될 문장들을 적는다.
}
```
=> 첫 번째 조건식부터 순서대로 평가해서 결과가 참인 조건식을 만나면 해당 블럭만 수행하고 끝 그렇지 않으면 순서대로 else블럭의 문장들이 수행되는데 여기서도 else문장중 참인것이 나오면 그대로 if-else if문 전체를 빠져나온다.

###- 중첩if문
=> if문의 블럭 내에 또 다른 if문을 포함시키는것, 중첩의 횟수에는 거의 제한이 없다.
```
if(조건식1) {
     // 조건식1의 연산결과가 true일 때 수행될 문장들을 적는다.
     if (조건식2)  {
                //조건식1과 조건식2가 모두 true일 때 수행될 문장들
     } else {
                // 조건식1이 true이고, 조건식2가 false일 때 수행되는 문장들
     }
} else {
      // 조건식1이 false일 때 수행되는 문장들
}                
```
=> 내부의 if문은 외부의 if문보다 안쪽으로 들여쓰기를 해서 두 if문의 범위가 명확히 구분될 수 있도록 작성해야 한다.

##2. switch문
=> 하나의 조건식으로 많은 경우의 수를 처리할 수 있고 표현도 간결하다. 그렇기 때문에 처리할 경우의 수가 많은 경우 if문 보다는 switch문으로 작성하는 것이 좋다. 다만 switch문은 제약조건이 있기 때문에 경우의 수가 많은 경우에도 if문으로 작성해야 할 때가 있다.

- switch문 순서
1. 조건식을 계산한다
2. 조건식의 결과와 일치하는 case문으로 이동한다.(조건식과 일치하는 case문이 하나도 없을 경우 default문으로 이동한다. / default문은 if문의 else블럭과 같은 역할을 한다고 보면됨 )
3. 이후의 문장들을 수행한다.
4. break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나간다.(break문은 각 case문의 영역을 구분하는 역할을 한다. / 경우에 따라서 고의적으로 생략하는 경우가 아니면 빼면 안된다.)

- switch문의 제약조건
1. switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
2. case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.

* (Math.random() * 3) + 1 가위바위보 만들때 쓰는 메서드

#<반복문> - for, while, do-while
###=> 반복문 : 어떤 작업이 반복적으로 수행되도록 할 때 사용, for문이나 while문에 속한 문장은 조건에 따라 한 번도 수행되지 않을 수 있지만 
do-while문에 속한 문장은 무조건 최소한 한 번은 수행될 것이 보장된다.
###=> if문과 마찬가지로 주어진 조건식이 true이면 참이고 false이면 거짓으로 간주
###=> for과 while은 비슷해서 어느 쪽을 선택해도 좋으나 for문은 주로 반복횟수를 알고 있을 때 사용한다.

## 1. for문 
=> 반복 횟수를 알고 있을 때 적합,
- for문의 구성
1. 초기화, 조건식, 증감식, 블럭  총 4부분으로 이루어져 있다.
2. 조건식이 참인 동안 블럭{} 내의 문장들을 반복하다가 거짓이 되면 반복문을 벗어난다.
3. 제일먼저 초기화가 수행되고 , 그 이후부터는 조건식이 참인 동안 조건식 -> 수행될 문장 -> 증감식 의 순서로 계속 반복된다 그러다가 조건식이 거짓이 되면 for문 전체를 빠져나가게 된다.

```
ex) for(int i=1;i<=10;i++) {...} -> int i = 1 (초기화), i<=10 (조건식), i++(중감식)
``` 

- 초기화 : 반복문에 사용될 변수를 초기화하는 부분, 처음에 한번만 수행, 변수가 둘 이상일 경우 콤마를 구분자로 변수를 초기화
- 조건식 : 조건식의 값이 참이면 반복 계속, 거짓이면 반복 중단
- 증감식 : 반복문을 제어하는 변수의 값을 증가 또는 감소 시키는 식이다.
* print : 가로출력, println : 세로출력

=> 위의 세 가지 요소는 필요하지 않으면 모두 생략할 수 있다, 조건식이 생략된 경우 참으로 간주되어 무한 반복문이 된다.

* 나머지 연산자% 사용시 값의 순환, 나누기 연산자/ 사용시 특정 범위의 값들 반복의 결과를 얻을 수 있다.

##-중첩 for문
=> 중첩의 횟수는 거의 제한이 없다, 대표적인 예로 별찍기가 있다. (i가 세로 j가 가로)

##- 향상된 for문
=> 배열과 컬렉션에 저장된 요소에 접근할 때 기존보다 편리한 방법으로 처리할 수 있도록 for문에 새로 추가된 문법
```
for( 타입 변수명 : 배열 또는 컬렉션) [
           // 반복할 문장
           }
```
```
for(int i=0; i < arr.length; i++) {            for(int tmp : arr) {
    System.out.println(arr[i]);       <->        System.out.println(tmp);
    }                                           }
```
=> 위의 왼쪽은 일반적인 for문으로 오른쪽은 향상된 for문으로 작성되었다. 두 for문은 동등하다.
그러나 향상된 for문은 일반적은 for문과는 달리 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.

##2. while문
=> while문은 조건식이 '참'인 동안, 조건식이 거짓이 될 때까지 블럭{} 내의 문장을 반복한다.
```
while (조건식) {
        // 조건식의 연산결과가 참(true)인 동안, 반복될 문장들을 적는다.
}
```
- while문의 구성
1. 조건식이 참(true)이면 블럭{}안으로 들어가고, 거짓(false)이면 while문을 벗어난다.
2. 블럭{}의 문장을 수행하고 다시 조건식으로 돌아간다.

- for문과 while문 비교

```
<for문>

// 초기화, 조건식, 증감식
for(int i=1;i<=10;i++)  {
    System.out.prinln(i);
}
```
```

<while문>

int i=1; // 초기화

while(i<=10)  {  // 조건식
   System.out.println(i);
   i++; // 증감식
}
```

- while문의 조건식은 생략불가이다. 그래서 while문의 조건식이 항상 참이 되도록 하려면 반드시 true를 넣어야 한다 

##- do-while문
=> 기본적인 구조는 while문과 같으나 조건식과 블력{}의 순서를 바꿔놓은 것이다. 그래서 while문과는 다르게 블럭{}을 먼저 수행한 후 조건식을 평가한다.

=> while문은 조건식의 결과에 따라 블럭{}이 한 번도 수행되지 않을 수 있지만 do-while문은 최소한 한번은 수행될 것을 보장한다. (자주 쓰이진 않지만 반복적으로 사용자의 입력을 받아서 처리할때 유용)

```
do{
    // 조건식의 연산결과가 참일 때 수행될 문장들을 적는다.
} while (조건식);  <- 끝에 ';'을 잊지 않도록 주의
```

##3. break문
=> 자신이 포함된 가장 가까운 반복문을 벗어난다 주로 if문과 함께 사용되어 특정 조건을 만족하면 반복문을 벗어나도록 한다.

=> 무한 반복문에는 조건문과 break문이 항상 같이 사용된다.

##4. continue문
=> continue문은 반복문 내에서만 사용될 수 있으며 반복이 진행되는 도중에 countinue문을 만나면 반복문의 끝으로 이동하여 다음 반복으로 넘어간다. for문의 경우 증감식으로 이동하며 while문과 do-while문의 경우 조건식으로 이동한다.

=> continue문은 반복문 전체를 벗어나지 않고 다음 반복을 계속 수행한다는 점이 break문과 다르다.

=> 전체 반복 중에 특정조건을 만족하는 경우를 제외하고자 할 때 유용하다.

##4. 이름 붙은 반복문
=> break문은  근접한 단 하나의 반복문만 벗어날 수 있기 때문에 여러 개의 반복문이 중첩된 경우에는 중첩 반복문 앞에 이름을 붙이고 break문과 continue문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.







