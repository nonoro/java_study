## < 다형성(polymorphism) >

### 1. 다형성이란?
    - 여러 가지 형태를 가질 수 있는 능력
    - *** 조상 타입 참조 변수로 자손 타입 객체를 다루는 것*** 단! 상속 관계에 있을 때
    - 타입 불일치 = OK => Tv(조상) t = new SmartTv()(자손);  //  Tv는 참조변수 타입 SmartTv는 객체 타입
    - 자손 타입의 참조변수로 조상타입의 객체를 가리킬 수 없다, 
        => ex) Tv      t = new SmartTv();     //  OK 허용
               SmartTv s = new Tv();          //  에러
               Tv = 조상, SmartTv = 자손
                => 실제 사용할 수 있는 기능 보다 리모컨 버튼 갯수가 많으면 안됨 에러 뜸  (= 참조변수가 사용할 수 있는 메멉의 개수는 인스턴스 멤버 개수보다 같거나 적어야 한다.)
    - 같은 타입의 인스턴스지만 참조변수 타입이 다를 경우에는 사용할 수 있는 멤버의 개수가 달라진다.
    - 정리) 1) 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
            2) 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.
            3) 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스 멥버 개수보다 같거나 적어야 한다.
    - 장점 : 2가지가 있고 아래서 배울 것

### 2. 참조변수의 형변환 = 리모콘을 변경하여 이 객체에서 사용할 수 있는 멤버의 갯수를 늘렸다 줄였다 하는것
    - 사용할 수 있는 멤버의 갯수를 조절하는 것(주소값, 객체 등은 하나도 안변하고 멤버의 갯수만 변함) - 리모콘을 변경
    - 단 서로 상속관계에 있는 클래스 사이에서만 가능하고 자손타입의 참조변수를 조상타입의 참조변수로 또는 조상타입 참조변수를 자손타입 참조변수로의 형변환만 가능하다. ( 조상의 조상 (= Object)으로도 형변환 가능)
    - 자손타입 -> 조상타입(UP-casting) : 형변환 생략가능
    - 조상타입 -> 자손타입(down-casting) : 형변환 생략불가
    * 형변환시 실제 인스턴스가 무엇인지가 중요! 자손 -> 조상 이 경우에 실제 객체에 뭐가 있냐에 따라 에러가 발생할 수 있음! 이게 컴파일은 되는데 출력시 에러가 뜨는 경우가 있음
    * 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다 ( 이 말은 조상으로 객체를 생성한뒤 조상타입을 자손타입으로 변경한다는게 안된다는 말임 )

### 3. instanceof 연산자
    - 참조변수의 형변환 가능여부 확인에 사용 가능하면 true 반환
    - 주로 조건문에 사용되며 instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다. 그리고 연산의 결과로 true와 false 중의 하나를 반환한다.
    - 참조변수 형변환시 꼭 instanceof로 확인을 하고 함
    - 상속을 받으면 자기의 조상들과 자신은 instanceof 하면 다 참이 나옴 
    - 정리
        1) 형변환이 가능한지 확인
        2) 형변환
        3) instanceof는 자기 자신과 조상들에 대해서 참을 반환 
        
    * 참조변수의 형변환은 왜 하나요?
        => 참조변수(리모콘)을 변경함으로써 사용할 수 있는 멤버의 갯수를 조절하기 위해서
    * instanceof연산자는 언제 사용하나요?
        => 참조변수를 형변환하기 전에 형변환 가능여부를 확인할 때
     
### 4. 참조변수와 인스턴스의 연결
    - 조상 타입의 참조변수와 자손 타입의 참조변수의 차이점은 사용할 수 있는 멤버의 개수이다.
    - 메서드의 경우 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드(오버라이딩된 메서드)가 호출되지만 멤버변수의 경우 참조변수의 타입에 따라 달라진다.
    - 결론 : 멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.


### 5. 매개변수의 다형성
    - 참조형 매개변수는 메서드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.
    - 장점
        1) 다형적 매개변수
        2) 하나의 배열로 여러종류 객체 다루기 
    - 1) 다형적 매개변수
        * [다형성]  
            a) Tv t (조상) = new SmartTv(); (자손) : 조상타입의 참조변수로 자손객체 다루는 것! 
            b) 참조변수의 형변환 : 리모콘 바꾸기 - 사용할 수 있는 멤버갯수 조절
            c) instanceof 연산자 : 형변환 가능여부 체크
        1] 조상클래스의 참조변수를 사용한 매개변수를 이용하여 여러가지 계산을 하나의 메서드로 간단히 해결할 수 있다.

### 6. 여러 종류의 객체를 배열로 다루기
    - 보통 하나의 배열에 같은 타입 밖에 저장이 안됨 하지만 다형성을 이용하면 하나의 배열에 여러종류의 객체를 저장할 수 있다.
    - 조상타입의 배열에 자손들의 객체를 담을 수 있다.
    - Vector클래스 : Object 배열을 가지고있으며 가변 배열이 가능하고 배열의 크기를 정할 필요가없음 알아서 공간이 부족하면 늘려주고 너무 많으면 또 줄여주고 함 = 동적으로 크기관리가 되는 객체배열
    - Vector클래스의 주요 메서드
        a) Vector() : 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다. 10개 이상의 인스턴스가 저장되면, 자동적으로 크기가 증가한다.
        b) boolean add (Object o) : Vector에 객체를 추가한다. 추가에 성공하면 결과값으로 true, 실패하면 false를 반환한다.
        c) boolean remove (Object o) : Vector에 저장되어 있는 객체를 제거한다. 제거에 성공하면 true, 실패하면 false를 반환한다.
        d) boolean isEmpty() : Vector가 비어있는지 검사한다. 비어있으면 true, 비어있지 않으면 false를 반환한다.
        e) Object get(int index) : 지정된 위치(index)의 객체를 반환한다. 반환타입이 Object타입이므로 적절한 타입으로 형변환이 필요하다.
        f) int size() : Vector에 저장된 객체의 개수를 반환한다.