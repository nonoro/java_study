## < 오버라이딩(overriding) >

### 1. 오버라이딩이란? (= 메서드 오버라이딩, overriding = 덮어쓰다)
    => 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다. 상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게 변경해야하는 경우가 많다. 이럴 때 조상의 메서드를 오버라이딩 한다.
    
### 2. 오버라이딩의 조건
    => 오버라이딩은 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야 한다.
    
    -자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
        a) 메서드이름이 같아야 한다.
        b) 매개변수목록이 같아야 한다.
        c) 반환타입이 같아야 한다.
    => 요약 : 선언부(메서드 : 예시 : String getLocation()으로 조상클래스에서 상속받았을 경우 이게 선언부임)가 서로 일치해야 한다, 구현부(내용){ } 만 변경가능 
             다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

    1) 선언부가 조상 클래스의 메서드와 일치해야 한다
         선언부 : a) 메서드이름이 같아야 한다.
                 b) 매개변수목록이 같아야 한다.
                 c) 반환타입이 같아야 한햣
    2) 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
        => 접근 제어자의 접근범위를 넓은 것에서 좁은 것 순으로 나열하면 : public, protected, (default), private
    3) 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.(Exception은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있도록 선언한 것이기 때문에 자손 클래스에서 사용하면 안됨)
    4) 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.

### 3. 오버로딩 vs 오버라이딩 (근본적으로 이 둘은 관계가 없음)
    1) 오버로딩 : 기존에 없는 새로운 메서드를 정의하는 것 - 오버로딩은 메서드이름만 같고 안에 변수갯수가 다르거나 타입이 달라야됨, 즉 틀만 복사해서 안에 내용은 다르게쓰는것 (상속과 관계가 없음)
    2) 오버라이딩 : 상속받은 메서드의 내용을 변경하는 것 - 오버라이딩은 덮어쓰기임, 즉 부모클래스의 메서드들을 가져와서 쓸수있지만 자손 클래스에서 부모클래스의 메서드 내용을 바꿔서 선언하면 super을 붙이지 않는이상 부모클래스의 메서드내용은 출력에 반영이 되지않고 자손클래스에서 선언한 출력이 반영됨 
                  만약 부모클래스에 x = 10, y = 30 이 있었고 부모클래스를 상속받은 자손클래스에 y = 20 이 있다면 x = 10은 상속받아서 그대로 쓰지만 y값은 상속받고나서 30을 20으로 덮어쓰기했기 때문에 y = 30의 값으로 출력됨 (상소고가 관련이 있음)

    * 329p 예시 설명 
    => class Parent() {
            void parentMethod() {}
        }
        class Child extends Parent {
            void parentMethod() {}           //  오버라이딩
            void parentMethod(int i) {}      //  오버로딩

            void childMethod() {}            //  메서드 정의
            void childtMethod(int i) {}      //  오버로딩
            void childtMethod() {}           //  중복정의 (에러)

### 4. super (= this와 거의 같음)
    => super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.(객체 자신을 가리키는 참조변수)
    => 인스턴스 메서드(생성자)내에서만 존재 , static메서드내에서 사용불가
    => 멤버변수와 지역변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤봐와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.

    * this = lv(지역변수)와 iv(인스턴스변수) 구별에 사용
    * super = 조상멤버와 자신멤버 구별을 위해 사용

### 5. super() - 조상 클래스의 생성자 (위에서 배운 참조변수 super와 전혀 연관이없음), (얘는 그냥 this()처럼 생성자일분임 super())
    1) 조상의 생성자를 호출할 때 사용    ( 생성자와 초기화블럭은 상속이 안됨 이거 명심하고 있을 것! )
    2) 조상의 멤버는 조상의 생성자를 호출해서 초기화
    * Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자 this() 또는 super()를 호출해야한다. 그렇지 않으면 컴파일러가 자동적으로 super();를 생성자의 첫 줄에 삽입한다
    * 인스턴스 생성시 클래스를 선택하는 것만큼 생성자를 선택하는 것도 중요
        a) 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
        b) 생성자 - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?
    ************ 생성자의 첫 줄에 반드시 생성자를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입 ************

    => 예시
        class Point {
            int x;
            int y;

            Point() {
                this(0,0);   // 첫 줄에 생성자 호출
            }
            
            Point(int x, int y) {
                this.x = x;    //  이 경우 첫 줄에 생성자가 호출이 안되어있음 그래서 컴파일시 자동으로 super(); 이게 추가됨
                this.y = y;
            }  
        }

        컴파일 된 후
        class Point extends Object {    //  extends Object 자동생성
            int x;
            int y;

            Point() {
                this(0,0);   // 첫 줄에 생성자 호출
            }
            
            Point(int x, int y) {
                super();              //  super(); 자동생성
                this.x = x;    
                this.y = y;
            }  
        }
        


    