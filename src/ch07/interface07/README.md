## < 인터페이스(interface) >

### 1. 인터페이스란?
    - 추상메서드의 집합(인터페이스의 핵심!), But 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 가질 수 없다.
    - 오직 추상메서드와 상수만을 멤버로 가질 수 있다.
    - 구현된 것이 전혀 없는 설계도. 껍데기 (모든 멤버가 public)

### 2. 인터페이스의 작성    
    -interface 인터페이스이름 {
        public static final 타입 상수이름 = 값;    //  상수만 가질 수 있음 / 변수, iv, cv 는 가질수 없음
        public abstract 메서드이름(매개변수목록);   //  추상메서드  얘가 핵심 
    - 항상 인터페이스의 모든 메서드는 public이고 abstract 이여서 생략가능 
    - 마찬가지로 인터페이스의 모든 상수는 항상 public이고 static이고 final 이여서 생략가능 예외는 없다

### 3. 인터페이스의 상속
    - 인터페이스의 조상은 인터페이스만 가능 (Object가 최고 조상이 아님) = 인터페이스는 인터페이스로부터만 상속받을 수 있다.
    - 다중 상속이 가능.(조상이 여러개) => 예시 : interface Fightable extends Movable, Attackable {}

### 4. 인터페이스의 구현
    - 인터페이스에 정의된 추상 메서드를 완성하는 것 = 구현
        => class 클래스이름 implements 인터페이스이름 {                   //  상속은 extends 인터페이스는 implements 사용하는 키워드가 다름
                //  인터페이스에 정의된 추상메서드를 모두 구현해야 한다.
            }
    - 일부만 구현하는 경우, 클래스 앞에 abstract를 붙여야 함. (추상클래스와 같음)


### 정리)
#### 1. 인터페이스란? : ***추상 메서드의 집합*** + 상수, static메서드, 디폴트메서드  ( 암기!!!! )
#### 2. 인터페이스의 구현이란? : 인터페이스의 추상메서드 몸통{} 만들기(미완성 설계도 완성하기)
```aidl
class AudioPlayer(완성된 설계도) extends Player(미완성 설계도) {
    void play(int pos) { /* 내용 생략 */ }           //  추상메서드를 구현
    void stop() { /* 내용 생략 */ }                  //  추상메서드를 구현
    }
    
class Fighter(완성된 설계도) implements Fightable(미완성 설계도) {
    public void move(int x, int y) { /* 내용 생략 */ }   //  인터페이스 구현
    public void attack(Unit u) { /* 내용 생략 */ }       //  인터페이스 구현
    }
```
#### 3. 추상 클래스와 인터페이스의 공통점은? : 추상 메서드를 가지고 있다.(미완성 설계도)
#### 4. 추상 클래스와 인터페이스의 차이점은? : 인터페이스는 iv를 가질 수 없다.

### 5. 인터페이스를 이용한 다형성
    - 다형성에서 자손클래스의 인스턴스를 조상타입의 참조변수로 참조하는 것이 가능했고 인터페이스도 마찬가지로 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있고 인터페이스 타입으로 형변환도 가능하다.
    - 인터페이스는 메서드의 매개변수의 타입으로 사용될 수 있다.
    - 인터페이스의 타입 매개변수는 인터페이스를 구현한 클래스의 객체만 가능하다.
    
```
예시) interface Fightable {
        void move(int x, int y);
        void attack(Fightable f);    //   *** 매개변수의 타입이 인터페이스라는것은 Fightable 인터페이스를 구현한 클래스의 객체(인스턴스)만 받겠다는 뜻임
```
    - 인터페이스를 메서드의 리턴타입으로 지정할 수 있다. => 이 경우 인터페이스를 구현한 클래스의 인스턴스를 리턴한다(반환한다)
```
Fightable method()                        //  반환(리턴)타입이 Fightable(인터페이스)이면 Fightable 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 뜻
        Fighter f = new Fighter();
        return f; 
```

### 6. 인터페이스의 장점
    - 인터페이스란 규격을 정해놓고 그렇게하도록 강제하기 위한 것
    - 두 대상(객체) 간의 '연결, 대화, 소통'을 돕는 '중간 역할'을 한다.
    1) 개발시간을 단축시킬 수 있다.
        => 일단 인터페이스가 작성되면, 이를 사용해 프로그램을 작성하는 것이 가능하다. 메서드를 호출하는 쪽에서 메서드 내용에 관계없이 선언부 내용만 알면 된다.
           그리고 동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하게 하면 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을 진행할 수 있다.
    2) 표준화가 가능하다
        => 프로젝트에 사용되는 기본 틀을 인터페이스로 작성하여 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 일관되고 정형화된 프로그램의 개발이 가능하다.
        => JDBC = 인터페이스의 집합(표준) : 각자 JDBC에 인터페이스규격에 맞춰서 개발을 하면 DB가 바뀌어도 각 DB회사의 기능에 의존하지않고 DB회사를 바꿔도 프로그램은 거의 변경을 안해도 된다.
    3) 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
    4) 독립적인 프로그래밍이 가능하다.
        => 인터페이스 이용 시 클래스의 선언과 구현을 분리시킬 수 있어서 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다. 
           클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다.
    5) 변경에 유리하다 : 예시) 윈도우(인터페이스=껍데기)가 같으면 컴퓨터 본체(하드웨어)가 바뀌어도 똑같이 이용할 수 있다. = 알맹이가 바껴도 껍질은 그대로이기 때문에 사용하기 편하다.

### 7. 인터페이스의 이해
    - 선언(설계)와 구현(알맹이)을 분리시킬 수 있게 한다. = 변경에 유리하고 유연한 코드가 된다.
    - 인터페이스 덕분에 B가 변경되어도 A는 안바꿀 수 있게 된다.(느슨한 결합)
        => A가 B를 사용(A가 B에 의존) -> B를 C로 변경시 A도 변경해야됨 /  A가 I(인터페이스)를 사용(A가 I에 의존) -> I안에있는 것을 어떤것으로 바꾸든 A는 변경하지 않아도됨 

### 8. 디폴트 메서드와 static메서드
    - 인터페이스에 디폴트 메서드, static메서드 추가 가능.(JDK1.8부터)
    - 인터페이스에 새로운 메서드(추상 메서드)를 추가하기 어려움. => 해결책 : 디폴트 메서드
    - 디폴트 메서드는 인스턴스 메서드(인터페이스 원칙 위반) : 꼭 앞에 default를 붙여야됨 생략불가 접근제어자는 public 이며 생략가능
    - 디폴트 메서드가 기존의 메서드와 충돌할 때의 해결책
        a) 여러 인터페이스의 디폴트 메서드 간의 충돌
            => 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
        b) 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
            => 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다
        * !!!!!!!!!!그냥 충돌나면 우리가 직접 오버라이딩 하자!!!!!!!!!!




